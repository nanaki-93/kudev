// pkg/builder/tagger.go

package builder

import (
	"context"
	"fmt"
	"regexp"
	"time"

	"github.com/nanaki-93/kudev/pkg/hash"
)

const (
	// TagPrefix identifies kudev-generated image tags.
	TagPrefix = "kudev-"

	// TimestampFormat is the format for timestamps in tags.
	// Uses UTC, sortable format: YYYYMMDD-HHMMSS
	TimestampFormat = "20060102-150405"
)

// tagPattern validates kudev tag format.
var tagPattern = regexp.MustCompile(`^kudev-[a-f0-9]{8}(-\d{8}-\d{6})?$`)

// Tagger generates image tags based on source code hash.
type Tagger struct {
	calculator *hash.Calculator
}

// NewTagger creates a new tagger with the given hash calculator.
func NewTagger(calculator *hash.Calculator) *Tagger {
	return &Tagger{
		calculator: calculator,
	}
}

// GenerateTag creates an image tag based on source hash.
// If forceTimestamp is true, appends UTC timestamp to force rebuild.
func (t *Tagger) GenerateTag(ctx context.Context, forceTimestamp bool) (string, error) {
	// Calculate source hash
	sourceHash, err := t.calculator.Calculate(ctx)
	if err != nil {
		return "", fmt.Errorf("failed to calculate source hash: %w", err)
	}

	// Build tag
	tag := TagPrefix + sourceHash

	// Add timestamp if forced
	if forceTimestamp {
		timestamp := time.Now().UTC().Format(TimestampFormat)
		tag = fmt.Sprintf("%s-%s", tag, timestamp)
	}

	return tag, nil
}

// GetHash returns just the hash portion without generating full tag.
// Useful for cache checking before building.
func (t *Tagger) GetHash(ctx context.Context) (string, error) {
	return t.calculator.Calculate(ctx)
}

// IsKudevTag checks if a tag was generated by kudev.
func IsKudevTag(tag string) bool {
	return tagPattern.MatchString(tag)
}

// ParseTag extracts the hash from a kudev tag.
// Returns empty string if not a valid kudev tag.
func ParseTag(tag string) (hash string, hasTimestamp bool) {
	if !IsKudevTag(tag) {
		return "", false
	}

	// Remove prefix
	remainder := tag[len(TagPrefix):]

	// Check for timestamp
	if len(remainder) > 8 {
		return remainder[:8], true
	}

	return remainder, false
}

// TagInfo contains parsed information from a kudev tag.
type TagInfo struct {
	// Hash is the 8-character source hash.
	Hash string

	// HasTimestamp indicates if timestamp suffix was present.
	HasTimestamp bool

	// Timestamp is the parsed timestamp (if present).
	Timestamp time.Time
}

// ParseTagInfo extracts detailed information from a kudev tag.
func ParseTagInfo(tag string) (*TagInfo, error) {
	if !IsKudevTag(tag) {
		return nil, fmt.Errorf("not a kudev tag: %s", tag)
	}

	// Remove prefix
	remainder := tag[len(TagPrefix):]

	info := &TagInfo{
		Hash: remainder[:8],
	}

	// Check for timestamp
	if len(remainder) > 8 {
		info.HasTimestamp = true
		timestampStr := remainder[9:] // Skip the hyphen

		ts, err := time.Parse(TimestampFormat, timestampStr)
		if err != nil {
			return nil, fmt.Errorf("invalid timestamp in tag: %w", err)
		}
		info.Timestamp = ts
	}

	return info, nil
}

// CompareHashes checks if two tags have the same source hash.
// Useful for determining if rebuild is needed.
func CompareHashes(tag1, tag2 string) bool {
	hash1, _ := ParseTag(tag1)
	hash2, _ := ParseTag(tag2)

	if hash1 == "" || hash2 == "" {
		return false
	}

	return hash1 == hash2
}
